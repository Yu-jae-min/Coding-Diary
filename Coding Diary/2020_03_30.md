## # 오늘의 코딩
- **Algorithm** : repeat메소드와 slice메소드를 활용하여 알고리즘 문제를 해결하였다.
- **Ts** : 유니온 타입을 통해 다중 타입을 지정할 수 있다. (or연산자의 파이프 사용)
- **Ts** : 다중 타입을 사용할 때 any와 달리 유니온 타입은 사용한 뒤 타입 가드(조건문 등을 통한 처리)처리를 통해 타입의 추론이 가능하기 때문에 관련 api를 쉽게 자동 완성할 수 있다.
- 유니온 타입으로 인터페이스 두 개를 연결할 경우 함수 내부에서 공통 된 속성만 접근할 수 있다.
- **Ts** : 인터섹션 타입을 통해 다중 타입을 지정할 수 있다. (and연산자의 & 사용)
- **Ts** : 인터섹션 타입으로 인터페이스 두 개를 연결할 경우 인터페이스가 가진 모든 속성에 접근이 가능하다.
- **Ts** : 유니온타입과 인터섹션타입의 공통점은 연결 된 모든 타입을 취급한다는 점이다. 여기서 차이점은 유니온 타입의 경우 함수 내부에서 보장된 타입(연결 된 타입들의 공통 속성)만 추론된다는 것이고 인터섹션 타입은 모든 타입의 접근이 가능하다.
- **Ts** : 함수의 파라미터가 인터페이스 두 개를 취급하는 유니온 타입인 경우에도 함수를 호출할 경우 인자로 전달하는 값이 유니온 타입으로 연결 된 인터페이스 두 개의 속성 모두 전달이 가능하다. 하지만 전달 된 값에 접근 시 에러를 발생하게 된다. 이 말은 유니온 타입의 보장된 타입만 추론된다는 것은 함수 내부에서만 적용된다는 것을 알 수 있다. 그렇기 때문에 인터페이스를 활용한 유니온 타입의 경우 인자를 전달할 때 두 조건 중 하나의 조건을 만족하는 인자를 전달하여야한다.
- **Ts** : 함수의 파라미터가 인터페이스 두 개를 취급하는 인터섹션의 타입인 경우 인자로 전달하는 값이 인터페이스 두 개가 가진 모든 타입을 만족하는 인자를 전달하여야한다.
- **Ts** : 유니온타입과 인터섹션 타입의 차이점은 유니온 타입은 다중 타입 중 하나를 선택하여 사용하는 개념이고, 인터섹션 타입은 다중 타입을 조합하여 새로운 타입을 만든다는 개념이다.
- **Ts** : enum타입의 경우 숫자로 초기화를 하지 않으면 0부터 시작해 1씩 증가한다. 숫자로 초기화를 하면 초기화한 값부터 1씩 증가한다.
- **Ts** : enum타입의 속성은 문자를 할당할 수 있다.
- **Ts** : 함수의 파라미터로 enum타입을 지정하는 경우 enum타입이 가진 속성만 인자로 넘겨줄 수 있다. 예를 들어 함수의 파라미터를 param: Answer로 지정할 경우 인자는 Answer.Nike 처럼 enum이 가진 속성을 인자로 넘겨주어야하는 것이다. 드롭다운 등의 목록이 필요한 형태에서 enum을 정의해서 사용한다.
- **Js** : 객체는 hasOwnProperty 메소드를 통해 자신이 가진 프로퍼티를 확인할 수 있다. user라는 변수에 name : ‘Mike’라는 객체를 할당하게 되면 user.hasOwnProperty(‘name’)가 true가 된다.
- **Js** : hasOwnProperty 메소드를 통해 객체의 프로퍼티를 확인할 때 hasOwnProperty 프로퍼티가 존재하는지 확인한 후 없으면 \__proto\__안에 있는 hasOwnProperty를 확인하여 찾는다. 위와 같은 경우 hasOwnProperty를 우선적으로 찾고 없기 때문에 user에 \__proto\__ 내부에 있는 hasOwnProperty를 찾고 그 안에 있는 name을 찾아 true를 반환하는 것이다.
- **Js** : \__proto\__를 활용하여 프로퍼티를 상속할 수 있다. 상위 개념 객체를 생성한 뒤 ‘상속받을 객체.\__proto\__ = 상위개념 객체’ 를 통해 프로퍼티를 상속할 수 있다. 예를 들어 car라는 상위 객체를 만든 뒤 bmw.\__proto\__ = car 와 같이 작성하면 car가 bmw에 프로토타입이 되는 것이다. 즉 bmw는 car에 상속을 받는 것이다.
- **Js** : 객체의 프로퍼티에 접근할 때 ‘객체.프로퍼티명’으로 접근하게 되는데 접근하는 프로퍼티가 객체에 존재하면 거기서 탐색을 멈추고, 존재하지 않으면 객체의 \__proto\__을 찾아보게 된다.
- **Js** : 프로토타입 체인으로 상속은 계속해서 이어질 수 있다. 객체1 <- 객체1을 상속받은 객체2 <- 객체2를 상속받은 객체3과 같은 형태인 것이다.
- **Js** : Objact.values 나 Objact.keys과 같이 키/값과 관련된 객체 메서드는 상속된 프로퍼티가 나오지 않는다. for in문을 통해서는 프로토타입에서 정의한 프로퍼티까지 전부 순회할 수 있다. 또한 객체가 상속받지 않은, 즉 직접 가지고 있는 프로퍼티를 확인하기 위해 hasOwnProperty 메소드를 사용할 수 있다. 
- **Js** : ‘상속받을 객체.\__proto\__ = 상위개념 객체’를 통해 프로퍼티를 상속받을 수도 있지만 상속받을 객체가 여러 개라면 위와 같은 코드를 중복으로 작성해야한다. 이런 경우 ‘상위객체.prototype.프로퍼티명 =  할당 값’을 통해 상속받을 객체가 가질 prototype을 미리 지정할 수 있다. 간단히 말해 \__proto\__를 미리 추가해놓는 것이다.
- **Js** : 생성자 함수가 새로운 객체를 만들어낼 때 그 객체는 생성자의 instance가 된다. 이를 확인하기 위해 instaceof 메소드를 활용할 수 있다. ‘상속받은 객체 instanceof 상위 객체’로 사용하며 boolean값이 출력된다.
- **Js** : 인스턴스 객체는 constructor라는 프로퍼티를 가지는데 이는 생성자를 가리킨다. 이를 통해 인스턴스 객체가 어떤 생성자를 통해 생성되었는지 확인할 수 있다. 하지만 constructor는 수동으로도 지정할 수 있기 때문에 명확하지않다.
- **Js** : 빌트인 자바스크립트 api를 사용할 수 있는 이유는 상위 prototype이 있기 때문이다. 예시로 arr이라는 변수에 빈 배열을 담아놓고 arr을 출력한 후 prototype을 확인해보면 배열과 관련 된 api들이 존재하는 것을 확인할 수 있다.
- **Js** : 생성자 함수로 클래스와 같이 구현할 수 있다. 객체지향 언어에 익숙한 사람들을 위해 나온 것이 클래스 기반의 문법을 제공한 것이다. 바벨로 돌려보면 클래스 문법이 생성자 함수를 사용한 것을 확인할 수 있다.
- **Ts** : 타입스크립트에서 클래스 사용 시 상단에 따로 타입을 먼저 지정해주어야하며 constructor의 파라미터 타입 또한 지정해주어야한다. 또한 private, public, protected 등의 접근제어자 속성으로 멤버 변수의 사용 범위를 지정할 수 있으며 readonly 속성을 통해 읽기 전용 프로퍼티로 만들 수 있다.

<br>

## # 느낀점
오늘은 타입스크립트 강의를 수강하며 유니온 타입과 인터섹션 타입, 또 이넘 타입에 대해 공부해보았다. 유니온 타입과 인터섹션 타입은 다중 타입을 활용한다는 점에서 비슷하지만 유니온 타입은 타입을 선택해서 사용하는 것이라면 인터섹션 타입은 다중 타입을 합쳐 새로운 타입을 만들어낸다는 개념으로 이해했다. 또한 열거형 타입인 이넘 타입은 드롭다운이나 목록의 형태에서 사용한다는 것을 알 수 있었다. 그리고 강의 중간에 객체 지향 프로그래밍의 핵심인 생성자와 프로토타입에 대한 개념도 나왔다. 자바스크립트의 개념을 공부하며 접해본 적이 있었지만 복습한다는 마음으로 다시 한번 공부해보았다. 복습해보며 복습의 중요성을 다시 한번 깨달을 수 있었다. 어떠한 개념을 적립할 때에는 남에게 구두로 설명해줄 수 있을때 까지 무한 복습해야된다는 것을 느낄 수 있었다.
