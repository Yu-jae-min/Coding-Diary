## # 오늘의 코딩 2022.04.29

- **NextJs / 프로젝트 생성** : npx create-next-app@latest 로 최신버전의 nextjs 프로젝트를 생성할 수 있다. 또한 타입스크립트를 함께 활용하기 위해서 —typescript를 뒤에 붙여주면 된다.

- **Vscode / 터미널에 code명령 등록** : 터미널에서 code로 vscode를 실행하기 위해서 vscode에서 code명령을 터미널에 등록해주어야한다. vscode에서 command + shift + p 입력 후 code를 입력하면 shell command : install 'code' command in PATH 이라는 목록이 나오는데 이 목록을 클릭하기만 하면 된다. 그 후 터미널에서 code ‘프로젝트명’을 입력하여 vscode를 실행할 수 있다.

- **NextJs / 프로젝트의 실행** : Next.js 설치 시 'package.json' 에 'scripts' 를 추가하게 된다. 이 스크립트는 애플리케이션 개발의 여러 단계를 참조한다. scripts를 참조하여 터미널에서 NextJs 프로젝트를 실행시킬 때 3가지로 나누어 실행할 수 있다. (ex npm run ‘dev/build/start 중 하나’)
1. 'dev' - 'next dev' : 개발모드에서 Next.js를 시작하는 실행
2. 'build' - 'next build' : 프로덕션 용도로 애플리케이션을 빌드하는 실행
3. 'start' - 'next start' : Next.js 프로덕션 서버를 시작하는 실행<br>
next dev 커맨드에는 source map 과 hot code reloading 이 제공되어 디버깅 시 매우 유용하다. build, start 명령어는 운영 버전의 사이트를 로컬에서 배포하는데 사용해야 하는 명령어로 최종 사용자들에게 유익하지 않을 source map 과 hot code reloading 과 같은 부수적인 기능을 가지고 있지 않다.

- **library vs framework** : 라이브러리는 개발자로서 내가 사용하는 것, 내가 라이브러리를 불러와서 라이브러리를 사용해서 무언가를 한다. 프레임워크는 나의 코드를 불러오는 것, 프레임워크에서는 내 코드를 적절한 위치에 잘 적기만하면 프레임워크가 내 코드를 불러와서 동작시킨다. 즉 라이브러리는 내가 원하는대로 코드를 작성할 수 있고, 사용하고 싶을 때 사용할 수 있다. 예를 들어 cra로 react프로젝트를 시작하면 ReactDOM.render에서 ‘root’를 불러오는 것을 확인할 수 있고 app컴포넌트는 비어있는데 여기에 코드를 작성한다던가 원하는 폴더를 생성한다던가를 결정하여 react를 언제 부를지, 어떤 폴더 구조로 만들지 정할 수 있다. 자유도가 높은 것을 알 수 있다. 반면 프레임워크에서는 특정한 규칙을 따라야한다. 규칙을 따라야 모든게 정상적으로 작동한다. 예를 들어 cna로 next프로젝트를 시작하면 react와는 다르게 ReactDOM.render같이 기본적으로 무언가 불러오는 것을 확인할 수 있거나 하는 것이 존재하지 않는다. 이 과정을커스텀할 수 있는 곳이 없는 것이다. 할 수 있는 것은 pages폴더 안에 뭔가를 만드는 것 뿐이다. 즉 nextjs는 개발자가 볼 수 없는 곳에서 ReactDOM.render과 같은 기능을 알아서 실행하며 개발자가 직접 접근할 수 없고 개발자는 페이지 안에 들어가는 내용을 작성만 하는 것이다. 여기에서 알 수 있듯이 프레임워크는 코드를 어떤 곳에 넣으면 프레임워크가 그 코드를 부르는 형태인 것이다. 그렇기 때문에 nextjs는 react처럼 따로 라우팅 기능을 적용시키지 않아도 pages폴더 밑에 js파일을 만들고 js파일의 이름을 엔드포인트로 하여 url에 접근하면 동작하는 것을 확인할 수 있다.

- **NextJs / 라우팅 기능** : 페이지 라우팅 기능이 필요없다. js파일을 생성하면 js파일명을 url의 엔드포인트로 하여 접근할 수 있다. js파일 내부에 export default 되는 함수의 이름은 중요하지 않지만 export default 로 내보내야한다.  export나 export default가 없다면 에러가 발생한다. 단 index.js는 예외이다. index.js는 앱의 홈이 된다.

- **NextJs / 404에러 페이지** : pages에 about-us라는 js파일을 생성한 후 url에 about으로 접근하게 되면 404에러를 볼 수 있다. nextjs가 잘못된 이름으로 접근한 것을 자동적으로 캐치하여 404에러 페이지를 나타내는 것을 알 수 있다. react같은 경우에서는 404페이지를 만들어야하는데 next는 자동으로 나타낸다.

- **NextJs / jsx문법 사용** : react와 마찬가지로 jsx문법도 가능하다. 파일확장자가 jsx가 될 필요도 없고 react를 import할 필요도 없이 jsx문법을 사용할 수 있다. 단, useState나 useEffect같은 react hook을 사용해야할 경우에는 react를 import해서 사용해야한다.

- **NextJs / Static Pre Rendering** : Nextjs의 가장 좋은 기능 중 하나는 앱에 있는 페이지들이 미리 렌더링 된다는 것이다. 이 페이지들은 정적으로 생성된다. react는 CSR방식이며 브라우저가 자바스크립트를 가져와서  client-side의 자바스크립트가 모든 ui를 만든다. react에 CSR방식의 단점은 초기 렌더링이 느리다는 단점이 있으며 네트워크패널에서 no trottling을 slow로 바꿔보면 체감할 수 있다. 초기 렌더링에 흰 화면이 보이는데 이 흰 화면이 브라우저가 js를 요청하고 있는 것이다. js요청이 끝나면 흰 화면에 ui가 렌더링되는 것을 볼 수 있다. 또한 js사용이 비활성화화면 noscript라는 js사용이 비활성화일 때만 나타나는 태그를 사용자가 보게 된다. nextjs는 command + option + u로 소스 코드를 확인해보면 react와는 다르게 실제 DOM이 포함되는 것을 볼 수 있다. (react는 root만 있음) 그래서 느린 연결이거나 js가 비활성화여도 사용자는 최소 html은 확인할 수 있다. 즉 api로부터 가져오는 데이터가 로딩되는데 로딩전에 html은 볼 수 있는 것이다.

- **NextJs / hydration** : NextJs는 초기 상태를 활용해서 미리 렌더링을 하는데 이것이 pre-rendering 이라고 한다. 사용자가 페이지를 열면 pre-rendering된 HTML을 보게되고 react.js가 클라이언트로 전송됬을 때 react.js 앱이 되는 것이다. react.js를 프론트엔드 안에서 실행하는 것을 hydration이라고 한다. NestJs는 react.js를 백엔드에서 동작시켜서 미리 페이지를 만드는데 이게 초기 상태의 컴포넌트들을 렌더링하는 것이다. 초기 상태의 컴포넌트들에 렌더링이 끝나면 HTML이 되고 NextJs는 그 HTML을 페이지 소스코드에 넣어준다. 그렇기 때문에 react.js가 로딩되지 않더라도 사용자는 콘텐츠를 확인할 수 있다. 그리고 react.js가 로딩되면 이미 존재하는 HTML과 연결되어 일반적인 react.js 앱이 되는 것이다. 초기 상태의 컴포넌트로 된 미리 생성된 HTML 페이지를 먼저 띄우고 react.js를 받은 뒤 연결하여 동작하게 되는 것이다. HTML을 먼저 렌더링하기 때문에 SEO에 정말 좋다.

- **NextJs / Navigation** : NextJs에서는 a태그를 네비게이팅에 사용하면 안된다. 만약 a태그를 사용하여 네비게이팅을 하면 전체페이지가 다시 렌더링되는 것을 볼 수 있다. (페이지 이동 시 파비콘을 보면 확인할 수 있다.) 즉 클라이언트 사이드 네비게이션이 아니라는 뜻이다. 브라우저가 다른 페이지로 보내기 위해 전체 페이지를 새로고침한다는 얘기다. NextJs에서는 react의 Link컴포넌트처럼 네비게이팅에 사용하는 특정 컴포넌트가 존재한다. 특정 컴포넌트는 Link컴포넌트이며 클라이언트 사이드 네비게이션을 제공한다. 사용법은 import Link from 'next/link’로 Link컴포넌트를 가져오고 Link컴포넌트안에 a태그를 집어넣고 href=‘주소’를 Link컴포넌트에 인라인 속성으로 삽입한다. (ex Link href="/") 그 후 페이지를 이동해보면 페이지가 새로고침되지 않고 이동이 되는 것을 볼 수 있다. 훨~씬 빠르다. react와 마찬가지로 Link컴포넌트를 사용하지만 차이점은 NextJs에는 LInk컴포넌트 내부에 a태그가 있어야한다는 점이다. a태그가 있어야만 className을 지정한다던가, 스타일을 지정할 수 있다.

- **NextJs / useRouter**  : NextJs에서는 라우터와 연결해주는 useRouter hook이 있다. const router = useRouter()와 같이 router를 변수에 담아 콘솔에 찍어보면 location에 관한 정보를 확인할 수 있다. (ex asPath, back, basePath, pathname 등) 이런 location 정보들을 확인하여 네비게이션을 커스텀 할 수 있다. 예를 들어 `<a style={{ color: router.pathname === '/' ? 'red' : 'blue' }}>Home</a>` 이와 같이 작성하게 되면 pathname에 따라 네비게이션의 글자 색상을 바꿀 수 있다.

<br>

## # 느낀점

오늘은 Next.js 인강을 수강하였다. 프로젝트 생성 방법은 react 보일러플레이트인 cra과 동일하였다.
또한 react와 비교해보면서 라이브러리와 프레임워크에 차이점에 대해서도 알아보았다. 요약하면 라이브러리는 개발자가 필요할 때 가져다쓰는 것이고 프레임워크는 정해진 규칙에 따라 개발자가 맞추어 작성하는 것이다. 그리고 NextJs는 따로 라우팅 기능을 구현하지 않아도 export default로 내보낸 컴포넌트의 파일명을 통해 페이지에 접근할 수 있었다. 엄청나게 편리하다는 것을 느낄 수 있었다. 또한 파일명에 맞지 않는 주소로 접근 시 404에러 페이지를 따로 생성하지 않아도 404페이지가 나타나는 편리함도 볼 수 있었다. 그리고 전에 공부했던 렌더링 방식에서 나왔던 NextJs는 CSR + SSR방식이라는 것도 조금 체감할 수 있었다. react같은 경우에는 CSR방식으로 초기 렌더링 시 빈 HTML과 프로젝트에 필요한 js를 모두 다운받기 때문에 초기 렌더링이 느려 사용자가 접속했을 때 흰 화면을 보게 될 수가 있다. 하지만 NextJs는 초기에 컴포넌트들을 렌더링하여 HTML을 먼저 사용자에게 보여준 뒤 js로딩이 끝나면 HTML과 연결하는 방식이었다. 그래서 사용자는 흰 화면을 보지 않아도 되었다. 마치 SSR방식의 초기렌더링과 동일하게 동작하는 것을 볼 수 있었다. 이러한 특징이 SEO에도 유리하다고 한다.
그리고 페이지 이동 시에는 Link컴포넌트와 a태그를 함께 사용하여 이동하는데 전체 페이지가 새로고침 되지 않는 CSR방식으로 이동된다.
이러한 NextJs에 동작을 보며 CSR+SSR을 결합한 방식이라는 것을 체감할 수 있었다. 또한 NextJs가 가지고 있는 useRouter hook을 활용하여
네비게이션을 커스텀할 수 있었다. 오늘은 이와 같은 내용들을 학습하였는데 왜 Next.js가 많이 사용되는지 체감할 수 있었다.
편리한 기능들로 인해 개발자가 프로젝트를 생산하는데 생산성을 높일 수가 있고 사용자 또한 좋은 사용자 경험을 할 수가 있었다.
남은 강의도 잘 수강해서 Typescript와 NextJs를 결합하여 프로젝트에 적용시켜보아야겠다.
